"""
Author      : AnyGuy
Date        : 2023-10-09

Title       : V3-anonymize-db-file.py

Description : Here comes text
    
    - xy
    - xy
    - xy

"""

# Import Libraries
import sqlite3
import hashlib
import random
import csv
import os

# Global variables
global_primary_keys = []
global_foreign_keys = []
marked_primary_keys = {}  # Mapping of foreign keys to their corresponding primary keys dictionary
global_foreign_to_primary_mapping = {}  # Mapping of foreign keys to their corresponding primary keys

# Pre-defined constants and color maps
COLORS = {
    "GREEN": "\033[92m",
    "LIGHT_BLUE": "\033[94m",
    "ORANGE": "\033[93m",
    "RED": "\033[91m",
    "BLUE": "\033[94m",
    "ENDC": "\033[0m"
}

ACTIONS_DESCRIPTION = {
    "X": "Do nothing",
    "R": "Remove",
    "P": "Reduce Phone number",
    "E": "Reduce email address",
    "C": "Replace characters",
    "N": "Replace with random number",
    "B": "Reduce date by",
    "A": "Reduce CC expire date",
    "D": "Reduce precision",
    "S": "Make SHA256Hash Value"
}

def apply_action_x(value, action):
    return value

def apply_action_r(value, action):
    return None

def apply_action_n(value, action):
    digits = int(action[1])
    return str(random.randint(10**(digits-1), 10**digits - 1))

def apply_action_b(value, action):
    if not value:
        return None
    parts = value.split('-')
    if len(parts) != 3:  # Validate the date format
        return value  # Return the original value if it's not a valid date format
    year, month, day = parts
    if action[1] == "year":
        return year
    elif action[1] == "month":
        return month
    elif action[1] == "day":
        return day
    elif action[1] == "day/month":
        return f"{day}/{month}"
    elif action[1] == "day/year":
        return f"{day}/{year}"
    elif action[1] == "month/year":
        return f"{month}/{year}"
    else:
        return value

def apply_action_p(value, action):
    return reduce_phone_number(value)

def apply_action_e(value, action):
    return reduce_email(value)

def apply_action_c(value, action):
    value_str = str(value)  # Convert value to string
    keep_chars = int(action[1])
    replace_char = action[2]
    specific_amount = action[3]
    if len(value_str) > keep_chars:
        replace_with = replace_char * (specific_amount if specific_amount else len(value_str) - keep_chars)
        return value_str[:keep_chars] + replace_with
    else:
        return value_str

def apply_action_d(value, action):
    salary_limit = list(action[1].keys())
    salary_limit.sort()
    for limit in salary_limit:
        if value and value < limit:
            return action[1][limit]
    return None

def apply_action_a(value, action):
    return reduce_cc_expire_date(value)

def apply_action_s(value, action):
    return pseudo_anonymize(value)

# Mapping of action codes to their corresponding functions
ACTION_FUNCTIONS = {
    "X": apply_action_x,
    "R": apply_action_r,
    "N": apply_action_n,
    "B": apply_action_b,
    "P": apply_action_p,
    "E": apply_action_e,
    "C": apply_action_c,
    "D": apply_action_d,
    "A": apply_action_a,
    "S": apply_action_s
}

def get_foreign_key_info(conn):
    """
    Extracts foreign key information from the SQLite database schema.
    
    Args:
        conn (sqlite3.Connection): SQLite database connection.
        
    Returns:
        dict: A dictionary mapping tables to their foreign key columns, 
              the referenced tables, and the referenced primary keys.
    """
    foreign_keys_info = {}
    
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    tables = cursor.fetchall()
    
    for table in tables:
        table_name = table[0]
        cursor.execute(f"PRAGMA foreign_key_list({table_name});")
        fks = cursor.fetchall()
        for fk in fks:
            column_name = fk[3]
            referenced_table = fk[2]
            referenced_pk = fk[4]
            if table_name not in foreign_keys_info:
                foreign_keys_info[table_name] = []
            foreign_keys_info[table_name].append((column_name, referenced_table, referenced_pk))
    
    return foreign_keys_info

def clean_input(prompt=""):
    return input(prompt).replace('\\r', '')

def compute_sha256(file_path):
    with open(file_path, 'rb') as f:
        data = f.read()
        return hashlib.sha256(data).hexdigest()

def reduce_phone_number(phone):
    blocks = phone.split()
    if len(blocks) >= 3:
        return f"{blocks[0]} {blocks[1]} *** ** {blocks[-1]}"
    return phone

def reduce_email(email):
    parts = email.split('@')
    if len(parts) == 2:
        user, domain = parts
        if len(user) > 2:
            user = user[0] + '*' * (len(user) - 2) + user[-1]
        return f"{user}@{domain}"
    return email

def replace_characters(value, replace_char='*', specific_amount=None):
    if specific_amount:
        return replace_char * specific_amount
    return replace_char * len(value)

def reduce_cc_expire_date(date):
    parts = date.split('/')
    if len(parts) == 2:
        return f"**/{parts[1]}"
    return date

# This function is called when applying SHA256Hash to the data
def pseudo_anonymize(data):
    if data is None:
        return None
    return hashlib.sha256(str(data).encode()).hexdigest()

# This function is called when saving the data to a CSV file
def save_to_csv(data, headers, output_path):
    with open(output_path, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(headers)
        writer.writerows(data)

# This function is called when saving the data to the database
def save_to_db(data, headers, output_path, table_name):
    conn = sqlite3.connect(output_path)
    cursor = conn.cursor()
    cursor.execute(f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(headers)})")
    cursor.executemany(f"INSERT INTO {table_name} VALUES ({','.join(['?'] * len(headers))})", data)
    conn.commit()
    conn.close()

# This function is called when applying anonymization to the data
def apply_anonymization(data, actions, columns):
    anonymized_data = []
    for row in data:
        new_row = []
        for idx, col_name in enumerate(columns):
            value = row[idx]
            action = actions.get(col_name)
            if action:
                func = ACTION_FUNCTIONS.get(action[0])
                new_row.append(func(value, action))
            else:
                new_row.append(value)
        anonymized_data.append(tuple(new_row))
    return anonymized_data

# This function is called when processing user actions for each table
def process_table_columns(db_path, table_name):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute(f"PRAGMA table_info({table_name})")
    all_rows = cursor.fetchall()
    print(f"DEBUG: All rows for table {table_name}: {all_rows}")  # Debugging line
    columns = [row[1] for row in all_rows]
    print(f"DEBUG: Extracted columns for table {table_name}: {columns}")  # Debugging line
    conn.close()
    return columns

# This function is called when processing user actions for each column
def process_user_actions(columns, table_name):
    actions = {}
    foreign_to_primary_mapping = {}

    for col in columns:
        print(f"\nFor the column '{col}':")
        action = clean_input("""
        Choose an action:
        X - Do nothing
        R - Remove
        C - Replace characters with a specific character
        B - Reduce a date like birthday or registration date and keep only...
        P - Reduce Phone number and keep only the first 2 blocks and last block
        E - Reduce email address keeping only first and last characters before @ and domain
        N - Replace with random number  
        A - Reduce CC expire date and keep only year
        D - Reduce precision of values with (low, medium, high)
        S - Make SHA256Hash Value
        1 - Mark as Primary Key (PK)
        2 - Mark as Foreign Key (FK)
        Please type your choice: 
        """).upper()

        if action == "N":
            handle_action_n(col, actions)
        elif action == "B":
            handle_action_b(col, actions)
        elif action == "C":
            handle_action_c(col, actions)
        elif action == "D":
            handle_action_d(col, actions)
        elif action == "1":
            handle_primary_key(col, global_primary_keys, table_name)
        elif action == "2":
            handle_foreign_key(col, global_primary_keys, global_foreign_keys, foreign_to_primary_mapping, table_name)
        else:
            actions[col] = (action,)

    return actions, foreign_to_primary_mapping

def map_foreign_to_primary():
    for fk in global_foreign_keys:
        print(f"\nFor the foreign key '{fk}':")
        
        while True:
            for idx, pk in enumerate(global_primary_keys, 1):
                print(f"{idx} - PK {pk}")
            
            try:
                selection = int(clean_input("Enter the number of the associated primary key: ")) - 1
                if 0 <= selection < len(global_primary_keys):
                    print(f"Mapping FK {fk} to PK {global_primary_keys[selection]}")
                    global_foreign_to_primary_mapping[fk] = global_primary_keys[selection]
                    del global_primary_keys[selection]  # Remove from display list.
                    break  # exit the while loop once a valid selection is made
                else:
                    print("Invalid selection. Please try again.")
            except ValueError:
                print("Please enter a valid number.")

def handle_action_n(col, actions):
    digits = clean_input("How many digits for the random number? ")
    actions[col] = ("N", digits)

def handle_action_b(col, actions):
    birth_choice = clean_input("Choose date reduction, what do you want to keep? (day, month, year, day/month, day/year, month/year): ")
    actions[col] = ("B", birth_choice)

def handle_action_c(col, actions):
    keep_chars = int(clean_input("How many characters do you want to keep? "))
    replace_char = clean_input("With what should the rest be replaced (*, +, etc.)? ")
    specific_amount = clean_input("Do you want to replace it with a specific amount of characters (Y/N)? ").upper()
    if specific_amount == "Y":
        amount = int(clean_input("How many characters? "))
    else:
        amount = None
    actions[col] = ("C", keep_chars, replace_char, amount)

def handle_action_d(col, actions):
    precision_rules = {}
    while True:
        limit = clean_input("Provide a salary limit. Value of database LESS THEN [YOUR-VALUE] (or type 'done' to finish): ")
        if limit.lower() == "done":
            break
        label = clean_input(f"What should be displayed for salaries < {limit}? ")
        precision_rules[int(limit)] = label
    actions[col] = ("D", precision_rules)

def handle_primary_key(column_name, global_primary_keys, table_name):
    global_primary_keys.append(column_name)
    if table_name not in marked_primary_keys:
        marked_primary_keys[table_name] = []
    marked_primary_keys[table_name].append(column_name)

def handle_foreign_key(column_name, global_primary_keys, global_foreign_keys, foreign_to_primary_mapping, table_name):
    global_foreign_keys.append(column_name)
    print("Select the primary key that corresponds to the foreign key '{}' :\n".format(column_name))
    
    # Wenn keine Primärschlüssel vorhanden sind, geben Sie eine Meldung aus und kehren Sie zurück
    if not global_primary_keys:
        print("No primary keys have been set. You cannot mark this column set as a foreign key.")
        return

    # Listet alle als PK festgelegten Spalten auf
    for i, pk in enumerate(global_primary_keys, 1):
        print(f"{i} - PK {pk}")

    # Der Benutzer wählt aus den aufgelisteten PKs
    choice = int(clean_input("\nEnter the number of the associated primary key: "))
    referenced_pk = global_primary_keys[choice-1]
    referenced_table = table_name  # Der referenzierte Tisch ist der aktuelle Tisch

    foreign_to_primary_mapping[column_name] = (referenced_table, referenced_pk)

def generate_dynamic_join_query(primary_keys, foreign_keys, global_foreign_to_primary_mapping):
    if not primary_keys or not foreign_keys:
        return None  # Can't generate a join without primary and foreign keys
    
    # Extract the main table from the primary keys list
    main_table = primary_keys[0].split("_", 1)[1]  # Using split to convert "pk_tableName" to "tableName"

    join_clauses = []
    for fk in foreign_keys:
        referenced_table, referenced_pk = global_foreign_to_primary_mapping[fk]
        join_clauses.append(f"INNER JOIN {referenced_table} ON {main_table}.{fk} = {referenced_table}.{referenced_pk}")

    return f"SELECT * FROM {main_table} {' '.join(join_clauses)}"

def remove_unwanted_columns(data, headers, actions, global_primary_keys, global_foreign_keys):
    # Find indices of columns to be removed
    indices_to_remove = []
    
    # Remove columns marked for removal with the action "R"
    for col, action in actions.items():
        if action[0] == "R":
            indices_to_remove.append(headers.index(col))

    # Remove columns marked as primary or foreign keys
    for pk in global_primary_keys:
        col_name = pk.replace("pk_", "")
        if col_name in headers:
            indices_to_remove.append(headers.index(col_name))
            
    for fk in global_foreign_keys:
        col_name = fk.replace("fk_", "")
        if col_name in headers:
            indices_to_remove.append(headers.index(col_name))
            
    indices_to_remove = list(set(indices_to_remove))  # Remove duplicates
    indices_to_remove.sort(reverse=True)  # Sort in reverse so we can delete without affecting indices

    # Remove these columns from the data and headers
    new_data = []
    for row in data:
        new_row = list(row)  # Convert tuple to list
        for index in indices_to_remove:
            del new_row[index]
        new_data.append(tuple(new_row))  # Convert list back to tuple

    for index in indices_to_remove:
        del headers[index]

    return new_data, headers

def export_to_csv(output_db_path):
    table_name = "anonymized_joined_table"
    conn = sqlite3.connect(output_db_path)
    cursor = conn.cursor()
    cursor.execute(f"SELECT * FROM {table_name}")
    data = cursor.fetchall()
    headers = [desc[0] for desc in cursor.description]
    conn.close()

    csv_path = os.path.join(os.path.dirname(output_db_path), f"{table_name}.csv")
    save_to_csv(data, headers, csv_path)

def save_to_csv(data, headers, output_path):
    with open(output_path, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(headers)
        writer.writerows(data)

def get_all_table_names_and_fk_info(db_path):
    conn = sqlite3.connect(db_path)
    foreign_keys_info = get_foreign_key_info(conn)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    table_names = [row[0] for row in cursor.fetchall()]
    conn.close()
    return table_names, foreign_keys_info

def apply_anonymization(data, actions, columns, pk_transformations=None):
    anonymized_data = []
    for row in data:
        new_row = []
        for idx, col_name in enumerate(columns):
            value = row[idx]
            action = actions.get(col_name)
            if action:
                func = ACTION_FUNCTIONS.get(action[0])
                new_value = func(value, action)

                # If column is a primary key, save its transformation
                if col_name.startswith("pk_"):
                    pk_transformations[value] = new_value

                new_row.append(new_value)
            else:
                new_row.append(value)
        anonymized_data.append(tuple(new_row))
    return anonymized_data

def apply_anonymization_to_fk(data, columns, pk_transformations):
    """
    Apply consistent transformations to FKs based on transformations done on PKs.
    """
    anonymized_data = []
    for row in data:
        new_row = []
        for idx, col_name in enumerate(columns):
            value = row[idx]
            # If column is a foreign key, apply the transformation from its corresponding primary key
            if col_name.startswith("fk_") and value in pk_transformations:
                new_row.append(pk_transformations[value])
            else:
                new_row.append(value)
        anonymized_data.append(tuple(new_row))
    return anonymized_data

def main():
    db_path = clean_input("Please provide the path to the database file: ")
    original_hash = compute_sha256(db_path)
    output_db_path = os.path.join(clean_input("Please specify the directory for the new database: "), "anonymized.db")
    
    table_names, _ = get_all_table_names_and_fk_info(db_path)
    all_table_columns = {table: process_table_columns(db_path, table) for table in table_names}
    
    global_foreign_to_primary_mapping = {}  # Mapping of foreign keys to their corresponding primary keys
    all_anonymized_data = {}

    for table_name in table_names:
        print("\n##################################################")
        print("##################################################")
        print(f"\nProcessing table: {table_name}")

        columns = all_table_columns[table_name]
        actions = process_user_actions(columns, table_name)

        # Anonymize data based on chosen actions
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute(f"SELECT * FROM {table_name}")
        data = cursor.fetchall()
        conn.close()

        anonymized_data = apply_anonymization(data, actions, columns)
        all_anonymized_data[table_name] = (anonymized_data, columns)
    
    # Ask user to map foreign keys to primary keys after processing all tables
    global_foreign_to_primary_mapping.update(map_foreign_to_primary())

    # 4. Wende den dynamischen Join an.
    join_query = generate_dynamic_join_query(global_primary_keys, global_foreign_keys, global_foreign_to_primary_mapping)
    if join_query:
        conn = sqlite3.connect(output_db_path)
        cursor = conn.cursor()

        # Speichern Sie zuerst alle anonymisierten Daten in der Ausgabedatenbank
        for table_name, data_columns in all_anonymized_data.items():
            save_to_db(data_columns[0], data_columns[1], output_db_path, table_name)

        # Führen Sie die Join-Abfrage aus, um die Daten und die Spaltennamen zu erhalten
        cursor.execute(join_query)
        data = cursor.fetchall()
        valid_columns = [desc[0] for desc in cursor.description]

        # Entfernen Sie unerwünschte Spalten NACH dem Join
        data, valid_columns = remove_unwanted_columns(data, valid_columns, actions, global_primary_keys, global_foreign_keys)

        save_to_db(data, valid_columns, output_db_path, "anonymized_joined_table")
        save_to_csv(data, valid_columns, csv_output_path)
        conn.close()

        print(f"\nOriginal hash of the database: {original_hash}")

        # Compute the hash of the new database
        new_db_hash = compute_sha256(output_db_path)
        print(f"\nHash of the new database: {new_db_hash}")

        print(f"\n{COLORS['GREEN']}Anonymization process completed for all tables!{COLORS['ENDC']}")

# Call the main function if this script is run as the main module
if __name__ == "__main__":
    main()